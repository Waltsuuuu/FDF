// PARSING THE MAP
// init t_map with 0, 0.
// #1 Loop with get_next_line(fd) until line == NULL
// #2 Split the returned line -> char **values = ft_split(line, ' ')
// #3 Count the number of values in the line -> line_width = word_count(values)
// #4 Set/validate map width:
//     - If map.width == 0, set map.width = line_width
//     - Else if line_width != map.width, the map is invalid (inconsistent row length), return error
// #5 Allocate a row of t_points -> t_point *row = malloc(sizeof(t_point) * line_width);
// #6 Fill the row:
//     - For each value (x = 0 to line_width):
//         - row[x].x = x
//         - row[x].y = current_height (line number)
//         - row[x].z = ft_atoi(values[x])
// #7 Store the row in a linked list:
//     - Use ft_lstnew(row) to create a new list node
//     - Add it to the back of the list with ft_lstadd_back()
// #8 Increment current_height after each line (this will become map.height)
// #9 Free the original line and the split values
//
// After the loop:
// #10 Set map.height = ft_lstsize(linked_list)
// #11 Allocate map->points = malloc(sizeof(t_point *) * map->height);
// #12 Iterate through the linked list:
//     - Copy each row (node->content) into map->points[i]
// #13 Free the linked list nodes (ft_lstclear), but do not free the row pointers (they are now in map->points)
// #14 Return the map


Old main for testing mlx lib and map parsing.
int main(void)
{

		void	*mlx;
	void	*window;

	// Initialize MiniLibX
	mlx = mlx_init();
	if (!mlx)
		return (1);

	// Create a new window: width, height, title
	window = mlx_new_window(mlx, 800, 600, "MiniLibX Test");
	if (!window)
		return (1);

	// Keep the window open until manually closed
	mlx_loop(mlx);
	return (0);
	t_map *map;
	int fd = open("test_maps/42.fdf", O_RDONLY);

	map = parse_map(fd);
	close(fd);
	if (!map)
	{
		printf("Failed to parse map\n");
		return (1);
	}
	printf("Map parsed successfully!\n");
	printf("Width: %d, Height: %d\n", map->width, map->height);

	// print out the map points (only z-values)
	for (int y = 0; y < map->height; y++)
	{
		for (int x = 0; x < map->width; x++)
		{
			printf("%3d ", map->points[y][x].z);
		}
		printf("\n");
	}

	// cleanup
	for (int i = 0; i < map->height; i++)
		free(map->points[i]);
	free(map->points);
	free(map);

	return (0);
}